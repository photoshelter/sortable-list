<link rel="import" href="../polymer/polymer.html">

<!--
# sortable-list
`<sortable-list>`
Polymer 1.X and 2.X custom element for drag-and-drop reorder of items.

For typical use just wrap your dom-repeat template item with a `<sortable-list>`
element to get drag-and-drop reordering.

Relies on
[HTML 5 drag and drop](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API)
support, so if you need to support older browsers
which do not support HTML 5 drag and drop events then we suggest using a polyfill:

https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills


@demo demo/index.html
-->

<dom-module id="sortable-list">
  <template>
    <style>
      :host {
        display: block;
      }
      :host ::slotted(*) {
        @apply --sortable-list-item;
      }
    </style>
    <slot></slot>
  </template>

  <script>
    function getIndex(node) {
      var children = node.parentNode.children;
      return [].indexOf.call(children, node);
    }

    function dragstart(evt) {
      var index = getIndex(this);
      evt.dataTransfer.effectAllowed = "move";
      evt.dataTransfer.setData("index", index);
      this.classList.add('dragged');
    }

    function dragover(evt) {
      evt.preventDefault();
      evt.dataTransfer.dropEffect = "move";
    }

    function dragleave(evt) {
      evt.preventDefault();
      evt.target.classList.remove('dragOverBottom');
      evt.target.classList.remove('dragOverTop');
    }

    function handledrop(evt) {
      evt.preventDefault();
      evt.dataTransfer.dropEffect = "move";

      // Move up the dom tree until you find the direct child of SORTABLE-LIST
      var target = evt.target;
      target.classList.remove('dragOverBottom');
      target.classList.remove('dragOverTop');
      target.classList.remove('dragged');

      while(target.parentNode.tagName !== 'SORTABLE-LIST') {
        target = target.parentNode;
      }

      var current = Number(getIndex(target));
      var move = Number(evt.dataTransfer.getData("index"));

      if(current > move && this.direction === 'up') {
        current = current - 1;
      } else if (current < move && this.direction === 'down') {
        current = current + 1;
      }

      // set the underlying Array model new order
      if (move !== current) {
        var repeat;
        if(Polymer.Element){
          // 2.x
          repeat = this.querySelector('dom-repeat');
        }else {
          repeat = this.querySelector("template[is='dom-repeat']");
        }

        var data = repeat.items;
        var item = data.splice(move, 1);
        data.splice(current, null, item[0]);
        repeat.notifySplices('items', [
          { index: move, removed: [item], addedCount: 0, object: data, type: "splice" },
          { index: current, removed: [], addedCount: 1, object: data, type: "splice" }
        ]);
        this.fire('sort');
      }
    }

    Polymer({

      is: 'sortable-list',

      properties: {
        /**
         * A string to specifiy a specific drggable handle
         * Default is empty string, the entire item is draggable
         * If set handle with class=specifiedHandle is draggable instead of the entire item.
        **/
         handleSelector: {
           type: String,
           value: '',
         },
       },

      _addlisteners: function() {
        var self = this;
        var nodes = this.getEffectiveChildren();

        nodes.forEach(function(item) {
          var handle = item;
          if(item.tagName !== 'DOM-REPEAT' && this.handleSelector !== "") {
            if(!item.shadowRoot) {
              // if item does not have shadowRoot. Query handleSelector
              handle = item.querySelector('.'+this.handleSelector);
            } else {
              // if item does have shadowRoot. Query handleSelector in both light and shadow dom
              handle = item.querySelector('.'+this.handleSelector) || item.shadowRoot.querySelector('.'+this.handleSelector);
            }
          }
          if (!item.getAttribute('draggable') && !!handle) {
            handle.setAttribute('draggable', true);
            item.addEventListener('dragstart', dragstart, false);
            item.addEventListener('dragover', this.dragover.bind(this), false);
            item.addEventListener('dragleave', dragleave, false);
          }
        }.bind(this));
      },


      dragover: function(evt) {
        evt.preventDefault();
        evt.dataTransfer.dropEffect = "move";
        let currentY = evt.clientY;
        let previousY = this.previousY;
        if (currentY > previousY) {
          this.direction = 'down'
        } else if (previousY > currentY) {
          this.direction = 'up'
        }
        this.previousY = currentY;
        this.addDropTargetIndicator(evt.target);
      },

      addDropTargetIndicator: function(target) {
        if(this.direction === 'up') {
          target.classList.add('dragOverTop');
          target.classList.remove('dragOverBottom');
        } else if (this.direction === 'down') {
          target.classList.add('dragOverBottom');
          target.classList.remove('dragOverTop');
        } else {
          target.classList.remove('dragOverTop');
          target.classList.remove('dragOverBottom');
        }
      },

      attached: function() {
        var self = this;

        this.async(function() {
          self.addEventListener('drop', handledrop, false);
          var repeat;

          if(Polymer.Element){
            // 2.x
            repeat = this.querySelector('dom-repeat');
          }else {
            repeat = this.querySelector("template[is='dom-repeat']");
          }
          repeat.addEventListener('dom-change', function() {
            self._addlisteners();
          });

          self._addlisteners();
        });
      }
    });
  </script>
</dom-module>
